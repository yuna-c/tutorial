<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>알고있으면 유용한 자바스크립트 문법</title>
    <link rel="stylesheet" href="./css/reset.css">
</head>
<body>
    <div class="wrap">

        <h1>알고있으면 유용한 자바스크립트 문법</h1>

        <div class="code-info">
            <h2><strong>삼항연산자</strong></h2>
            <ul class="code-list">
                <li>condition ? true : false</li>
                <li>조건이 true가 되면 전체가 true, 아니면 false</li>
                <li><a href="grammar/example1.js" target="_blank">example1</a></li>
            </ul>
        </div>
        <pre>
            <code>
삼항 연산자
//condition ? true : false
//condition ? hello : bye


const array = [1, 2, 3, 4];
let test = '';
// if(array.length === 0){
//     text = '배열이 비어있습니다.';
// } else {
//     text = '배열이 비어있지 않습니다.';
// }

let text = array.length === 0 
    ? '배열이 비어있습니다!' 
    : '배열이 비어있지 않습니다!'
console.log(text);


// 비추천
const condition1 = false;
const condition2 = false;

const value = condition1
    ? '와우!'
    : condition2 
    ? 'blabla'
    : 'foo'

console.log(value);
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>Truthy and Falsy</strong></h2>
            <ul class="code-list">
                <li>Falsy : undefined, null, 0, '', NaN </li>
                <li><a href="grammar/example2.js" target="_blank">example2</a></li>
                <li><a href="grammar/example3.js" target="_blank">example3</a></li>
            </ul>
        </div>
        <pre>
            <code>
// falsy
console.log(!undefined); //undefined, null => falsy한 값으로 간주
console.log(!null);
console.log(!0); // 0이 아닌 값
console.log(!''); // 빈문자
console.log(!NaN);  // not a number 
console.log(!false);


// truthy
console.log(!3);
console.log(!'hello');
console.log(!['array']); // 배열
console.log(![]); // 빈배열
console.log(!{}); // 객체


const value = undefined/*{ a : 1 } , null*/;

// if (value) {
//     console.log('value가 Truthy하네요.');
// }

// const truthy = value ? true : false;
const truthy = !!value;
console.log(truthy);
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>Short-circuit evaluation</strong></h2>
            <ul class="code-list">
                <li>단축 평가 논리 계산법 : 논리 연산자를 통해서 코드를 더 짧게 쓰는 것</li>
                <li><a href="grammar/example4.js" target="_blank">and</a></li>
                <li><a href="grammar/example5.js" target="_blank">and</a></li>
                <li><a href="grammar/example6.js" target="_blank">or</a></li>
                <li><a href="grammar/example7.js" target="_blank">or</a></li>
            </ul>
        </div>
        <pre>
            <code>
true && true // true and
true && false // false
true || false // true or
false || true // true

// 논리 연산자는 true/false만으로 나뉘지 않는다 !(not) false

const dog = {
    name : '멍멍이'
};

const cat = {
    name : '고양이'
}

function getName(animal) {
    // if(animal) {
    //     return animal.name;
    // }
    // return undefined;

    // 단축 방법
    return animal && animal.name; 
}

const name = getName(cat); //dog 값이 있을 때는 멍멍이가, 없을 때는 undefind가 나온다
console.log(name);


//example

console.log(true && 'hello'); // and 연산자의 앞에 나오는게 true라면 연산 결과는 뒤에오는 게 되는 것이다 (true X = hello Y)
console.log(false && 'hello'); // 앞에 오는게 false라면 뒤에오는걸 보지도 않고 false를 return 한다
console.log('hello' && 'bye'); //bye because hello = truthy한 값

// and 연산자는 앞에 있는 값이 truty한 값이나 true면 뒤에있는 값이오고, 앞에 있는 값이 falsy하면 어림도없다
// falsy한 값
console.log(null && 'hello'); // null 
console.log(undefined && 'hello'); // undefined
console.log('' && 'hello');
console.log(0 && 'hello');

console.log(1 && 'hello');
console.log(1 && 1);
 


const object = { name : 'dfdfd' }; // { name : 1 } null
// 객체일수도 객체가 아닐 수도 있는 상황이라면
const name = object && object.name; //에러 안나고 실행이됨
console.log(name);


// null and ㅇㄹㄴ아릴
              

// or 연산자 : 어떤 값이 falsy하다면 대체로 사용할 값을 지정해 줄 때,
// const namelessDog = {
//     name : '',
// }

// function getName(animal) {
//     const name = animal && animal.name;
//     // if(!name) {
//     //     return '이름이 없는 동물입니다.';
//     // }
//     // return name;
//     return name || '이름이 없는 동물입니다.';

// }

// const name = getName(namelessDog)
// console.log(name);

const namelessDog = {
    name : '뭉뭉이',
}

function getName(animal){
    const name = animal && animal.name;
    if(!name ){ 
        return '이름이 없는 동물입니다';
    }
    return name;
}

const name = getName(namelessDog);
console.log(name);



// or
console.log(false || 'hello'); // falsy하거나 false이면 뒤의 값을 추출
console.log('' || '이름없다');
console.log(null || '널이다');
console.log(undefined || 'defined 되지 않았다');
console.log(0 || '영은 false');
console.log(NaN || 'not a number');


console.log(1 || '음?'); //1 
console.log(true || '여기 안본다');
console.log('와아' || '여기 안본다');
console.log([] || '배열');

            </code>
        </pre>

        <div class="code-info">
            <h2><strong>함수의 기본 파라미터</strong></h2>
            <ul class="code-list">
                <li>함수를 호출하게 될 때, 원래 넣어야할 파라미터를 넣지 않았을때, 기본값으로 사용하는 값을 정하는 것</li>
                <li><a href="grammar/example8.js" target="_blank">원의 너비 구하기</a></li>
                <li><a href="grammar/example9.js" target="_blank">원의 너비 구하기, 화살표 문법</a></li>
            </ul>
        </div>
        <pre>
            <code>
/* 원의 너비 구하기 */
function calculateCircleArea(r = 1) { // 이퀄싸인을 사용할 때 기본값을 1을 사용한다
    //단축 평가 논리 계산법 => 만약에 파라미터가 없으면 1을 기본값으로 사용하겠다
    //const radius = r || 1;
    //return Math.PI * radius  * radius; // 3.14 파이
    return Math.PI * r  * r; 
}

//area = calculateCircleArea(); 일때 기본값으로 사용 할 값 구하는 법
const area = calculateCircleArea(2);
console.log(area);

                

/* 화살표 문법 */
const calculateCircleArea =  (r = 1) =>  Math.PI * r * r;

//area = calculateCircleArea(); 일때 기본값으로 사용 할 값 구하는 법
const area = calculateCircleArea(2);
console.log(area);
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>조건문 더 스마트하게 쓰기</strong></h2>
            <ul class="code-list">
                <li><a href="grammar/example10.js" target="_blank">조건문</a></li>
                <li><a href="grammar/example11.js" target="_blank">조건문 화살표</a></li>
                <li><a href="grammar/example12.js" target="_blank">조건문 화살표</a></li>
            </ul>
        </div>
        <pre>
            <code>
/*
특정 값이 어떤 값인지 확인해야 할 때 조건문을 쓰는데
스마트하게 쓸 수 있는 방법 배우기
*/

function isAnimal(text) {
    // return (
    //     text === '고양이' || text === '개' || text === '거북이' || text === '너구리'
    // ); //이면 return true

    const animal = ['개', '고양이', '거북이', '너구리']; //배열안에 text 존재하면 true
    return animal.includes(text);
}

console.log(isAnimal('개'));
console.log(isAnimal('노트북')); //아니면 false


function isFood(text) {
    // return (
    //     text === '짬뽕' || text === '탕수육' || text === '짜장면' || text === '팔보채'
    // )
    const food = ['짜장면', '짬뽕', '탕수육', '팔보채'];
    return food.includes(text);
}

console.log(isFood('짜장면'));
console.log(isFood('강아지'));



/* 화살표 함수 */
const isAnimal = (text) => ['개', '고양이', '거북이', '너구리'].includes(text);

console.log(isAnimal('개'));
console.log(isAnimal('노트북')); //아니면 false

const isFood = (text) =>[ '짜장면', '탕수육', '팔보채', '짬뽕'].includes(text);

console.log(isFood('짜장면'));



function getSound(animal) {
    // if문이 한줄이면 블록을 생략 가능
    // if (animal === '개') return '멍멍'; 
    // if (animal === '고양이') return '야옹'; 
    // if (animal === '참새') return '짹짹'; 
    // if (animal === '비둘기') return '구구구구'; 
    // return '...?';

    //switch case
    // switch (animal){
    //     case '개' :
    //         return '멍멍!'; // switch case 안에 바로 return을하면 구지 break할 필요가 없다
    //     case '고양이' :
    //         return '야옹!';
    //     case '참새' :
    //         return '짹짹!';
    //     case '사람' :
    //         return '아 하기싫다!';  
    //     default :
    //         return '...? 알 수 없어';  
    // }

    //if 더 깔끔하게 = 객체 사용
    const sounds = {
        개 : '멍멍😊',
        고양이 : '야옹😊',
        참새 : '짹짹😊',
        비둘기 : '구구구구😊'
    };
44
    return sounds[animal] || '...?😊😊';

    //함수 넣어서 필요할 때 호출

}

console.log(getSound('개'));
console.log(getSound('고양이'));
console.log(getSound('인간'));


function makeSound(animal) {
    const tasks = { // 객체 활용코드
        개 : () => {
            console.log('멍멍!');
        },
        고양이() { //함수를 객체 안에다가 선언하는게 더 낫다
            console.log('야옹!');
        },
        비둘기(){ 
            console.log('구구!');
        },
        듀공 : ()=> {
            console.log('우오오오오');
        }, 
        참새 () {
            console.log('짹짹');
        }
    }

    const task = tasks[animal];
    if(!task){
        console.log('...?');
        return;
    }
    task();
}

makeSound('개');
makeSound('고양이');
makeSound('인간');
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>비구조화 할당(구조 분해)</strong></h2>
            <ul class="code-list">
                <li><a href="grammar/example13.js" target="_blank">객체 비구조화 문법</a></li>
                <li><a href="grammar/example14.js" target="_blank">배열 비구조화 문법</a></li>
                <li>비구조화 할당은 객체, 배열에도 할 수 있다.</li>
                <li><a href="grammar/example15.js" target="_blank">객체 깊숙한 곳에 있는 값 꺼내는 법</a></li>
            </ul>
        </div>
        <pre>
            <code>
/* 객체 비구조화 문법 */
// const object = { a : 1, b : 2 };

// 1,2가 밖으로 추출
// const { a, b } = object;
// console.log(a);
// console.log(b);

//비구조화 할당 문법은 함수의 파라미터에서도 사용할 수 있다.
/*
function print({ a, b }){
    console.log(a);
    console.log(b); 
}

print(object);
*/

// 만약 b값이 없다면 비구조화 할당을 통해, 기본 값을 정할 수 있다

const object = { a : 1 };
const { a, b = 2 } = object;
console.log(a);
console.log(b);
//console.log(b || 2); //undefind


// 비구조화 할당을 할 때 이름을 바꾸는 법
const animal = { 
    name : '멍멍이',
    type : '개'
};

//const nickname = animal.name;
const {name : nickname} = animal; //{ 원래있던이름 : 내가 바꿀 이름}
console.log(nickname);
console.log(animal);

// 연습
function biggerThanThree(numbers){
    const array = [];
    for(let i = 0; i < numbers.length; i++){
        if(numbers[i] > 3){
            array.push(numbers[i]);
        }
    }
    return array;
}

const numbers = [1, 2, 3, 4, 5, 6, 7];
console.log(biggerThanThree(numbers));


/* 배열 비구조화 문법 */

//const array = [1, 2]; //객체 비구조화 문법과 같이, 기본값을 넣어 줄 수 있다
const array = [];
// const one = array[0];
// const two = array[1];
// 대괄호에 넣어줌
const [one = 5, two = 2, three = 44] = array;

console.log(one);
console.log(two);
console.log(three);



/* 객체 깊숙한 곳에 있는 값 꺼내는 법 */

const deepObject = {
    state : {
        infomation : {
            name: 'yuna',
            languages: ['korean', 'english', 'chinese'],
        }
    },
    value : 5
}

// 1. 비구조화 할당 문법 두번사용
// const { name, languages } = deepObject.state.infomation;
// const { value } = deepObject;

// 2. 비구조화 할당을 한번 하면서 여러가지 정보를 다 빼오는 것
const {
    state: {
        infomation : {
            name, languages: [firstLang, secondLang]
        }
    },
    value
} = deepObject;

const extracted = {
    name,
    //languages,
    firstLang, secondLang,
    value
}

console.log(extracted);
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>spread 연산자</strong></h2>
            <ul class="code-list">
                <li>...</li>
                <li>객체 혹은 배열을 펼침</li>
                <li><a href="grammar/example16.js" target="_blank">spread 객체</a></li>
                <li><a href="grammar/example17.js" target="_blank">spread 배열</a></li>
                <li><a href="grammar/example21.js" target="_blank">spread 함수 인자</a></li>
            </ul>
        </div>
        <pre>
            <code>
//spread : 펼치다, 퍼뜨리다

// 방법1 spread 연산자 : 기존 객체를 복사하고 속성을 추가할 떄 사용
const slime = {
    name : '슬라임',
};

const cuteSlime = {
    // name : '슬라임',
    ...slime,
    attribute : 'cute'
};

const purpleCuteSlime = {
    // name : '슬라임',
    // attribute : 'cute',
    ...cuteSlime,
    color : 'purple'
};

const greenCuteSlime = {
    color : 'green',
    ...purpleCuteSlime,
    color : 'green'
}

// 방법2
// const slime = {
//     name : '슬라임',
// };

// const cuteSlime = slime;
// cuteSlime.attribute = 'cute';

// const purpleCuteSlime = cuteSlime;
// purpleCuteSlime.color = 'purple';

const { name , attribute , color } = purpleCuteSlime;


const extracted = {
    name,
    attribute,
    color
}
console.log(extracted);



console.log(slime);
console.log(cuteSlime);
console.log(purpleCuteSlime);
console.log(greenCuteSlime);

console.log(slime === cuteSlime);




const deepObject = {
    state : {
        information : {
            mama : 'yuna',
            length : [1, 2, 3, 4, 5],
        }
    },
    value : 5
}

const {
    state : {
        information : {
            mama, length: [first, second, third]
        }
    },
    value
} = deepObject;

const extract = {
    mama,
    //length,
    first, second, third,
    value
}
console.log(extract);


// 배열 spread
const animals = ['개', '고양이', '참새'];
const anotherAnimals = [ ...animals, '다람쥐'];
const autheorAnimals = anotherAnimals.concat('비둘기');

console.log(animals);
console.log(anotherAnimals);
console.log(autheorAnimals);
console.log(animals === anotherAnimals);


const numbers = [1, 2, 3, 4, 5];
const spreadNumbers = [...numbers, 1000, ...numbers];
console.log(numbers);
console.log(spreadNumbers);
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>rest</strong></h2>
            <ul class="code-list">
                <li>객체 배열, 함수의 파라미터에서 사용 가능</li>
                <li><a href="grammar/example18.js" target="_blank">rest 객체</a></li>
                <li><a href="grammar/example19.js" target="_blank">rest 배열</a></li>
                <li><a href="grammar/example20.js" target="_blank">rest 함수 파라미터</a></li>
                <li><a href="grammar/example22.js" target="_blank">퀴즈</a></li>
            </ul>
        </div>
        <pre>
            <code>
// rest

const purpleCuteSlime = {
    name : 'slime',
    attribute : 'cute',
    color : 'purple'
};

const { color, ...cuteSlime/*rest*/ } = purpleCuteSlime;
console.log(color);

//rest 를 사용할때 이름을 다르게 해도된다 ex cuteSlime
// console.log(rest);
console.log(cuteSlime);

const { attribute, ...slime} = cuteSlime;
console.log(cuteSlime);
console.log(slime);

// spread : 객체나 배열 안에 다른 객체를 퍼뜨리는 역할
// rest : 퍼져있는 것들을 다시 모아오는 역할


const numbers = [0, 1, 2, 3, 4, 5, 6];

// 비구조화 할당
const [one, two, ...Arest] = numbers; 
console.log(one);
console.log(two);
console.log(Arest);

// const [...rest, last] = numbers; 이렇게는 못씀
// 배열에서의 rest는 맨 마지막에 쓰임




// 파라미터에 넣어준 모든 값들을 합해주는 함수 만들기
// function sum(a, b, c, d, e, f, g){
function sum(...rest){ //모든 파라미터를 배열로 받아온다
    //return a + b + c + d + e + f + g;
    /*
    let result = 0;
    if(a){
        result += a;
    }
    if(b) result += b;
    if(c) result += c;
    if(d) result += d;
    if(e) result += e;
    if(f) result += f;
    if(g) result += g;
    return result;
    */
    // if(a){
    //     result += a;
    // }

    //이런식으로 파라미터를 받아 하나하나 인자를 더해줘야 하지만,
    //reduce를 통해 합산해준다
    return rest.reduce((acc, current) => acc + current, 0);
}

// 숫자 하나만 빠져도 연산이 안되기 때문에
console.log(sum(1,2,3,4,5,6,7,8,9,10));





function sum(...rest) {
    return rest.reduce((acc, current) => acc + current, 0);
}

const number = [1,2,3,4,5,6,7,8,9];
console.log(sum(...number));

function substact(x, y) { //x,y는 파라미터 : 함수에서 받아오는 값
    return x - y;
}

const numbers = [1, 2];
const result = substact(...numbers); //1,3 인자 : 함수를 사용할 떄 넣어주는 값
//const result = substact(numbers[0], numbers[1]) =  ...number ( spread )
console.log(result);




function max(...numbers){
    // return 0;
    // acc가 current보다 크면 그 결과값을 current로 하고 
    // 그렇지 않으면 acc가 결과값

    return numbers.reduce(
        //(acc, current) => (current < acc ? current : acc), //제일 작은 값일 때
        (acc, current) => (current > acc ? current : acc),
        numbers[0]
    );
}

const result = max(1, 2, 3, 4, 5, 6, 7, 8, 9, 20);
console.log(result);
            </code>
        </pre>

        <div class="code-info">
            <h2><strong>scope</strong></h2>
            <ul class="code-list">
                <li>스코프 : 변수, 함수 선언시 해당 변수, 함수가 어디서 어디까지 유효한지의 범위</li>
                <li><a href="grammar/example23.js" target="_blank">global</a></li>
                <li><a href="grammar/example24.js" target="_blank">function</a></li>
                <li><a href="grammar/example25.js" target="_blank">block</a></li>
                <li><a href="grammar/example26.js" target="_blank">hoisting</a></li>
                <li>호이스팅 : 아직 선언되지 않은 함수, 변수를 끌어올려서 사용할 수 있는 작동 방식</li>
            </ul>
        </div>
        <pre>
            <code>
// global scope 전역

const value = 'hello'; // global scope

function myFunction () {
    console.log('myFunction: ');
    console.log(value);
}

function otherFunction () { //함수형 스코프
    console.log('otherFunction: ');
    const value = 'bye!';
    console.log(value);
}

myFunction();
otherFunction();

console.log('global scope: ');
console.log(value);




// function scope : 특정 함수 범위내에서만 사용이 가능하다
const value = 'hello';

function myFunction() {
    const value = 'bye';
    const anotherValue = 'world';

    function functionInside() {
        console.log('function Inside :');
        console.log(value);
        console.log(anotherValue);
    }
    functionInside();
}

myFunction();
console.log('global Scope :')
console.log(value);
// console.log(anotherValue);




// block scope : if, for, switch문 같은 것을 작성할 때 중괄호 내부에서만 사용


const value = 'hello';

function myFunction() {

    const value = 'goodbye';
    if (true) {
        const value = 'world';
        console.log('block scope :');
        console.log(value);
    }
    console.log('function scope :');
    console.log(value);
}

myFunction();
console.log('global Scope :')
console.log(value);
// console.log(anotherValue);



//호이스팅 : 아직 선언되지 않은 함수, 변수를 끌어올려서 사용할 수 있는 작동 방식


myFunction(); // 선언이 되기 전에 호출 ~웬만하면 피해라

function myFunction() {
    console.log('hello world');
};


// 변수의(var) 호이스팅 , const,let은 호이스팅 X
var number;
console.log(number);
number = 2;
console.log(number);


function fn(){
    console.log(a);
    let a = 2;
}
fn();



            </code>
        </pre>


<!-- 
    <div class="code-info">
        <h2><strong></strong></h2>
        <ul class="code-list">
            <li></li>
        </ul>
    </div>
    <pre>
        <code>
        </code>
    </pre>
-->

    </div>
</body>
</html>
